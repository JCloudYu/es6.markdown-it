/**
Copyright (c) 2014 Vitaly Puzrin, Alex Kocharin.

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
**/

import m_QQ2PJP7SE1FV7OJ2M4NP36EFRS5IJQT8G3OQPRT0507KHS04 from "./QQ2PJP7SE1FV7OJ2M4NP36EFRS5IJQT8G3OQPRT0507KHS04.esm.js";
import m_TN12OD91GP0CUCC9GES6PCR3MJO0HP5UB5EOHEFK9KI2LJLM from "./TN12OD91GP0CUCC9GES6PCR3MJO0HP5UB5EOHEFK9KI2LJLM.esm.js";
import m_D1TE8ES05J0BT6F4PTNEQQINJH41THEGUK3K7DIBC9SPKAFJ from "./D1TE8ES05J0BT6F4PTNEQQINJH41THEGUK3K7DIBC9SPKAFJ.esm.js";
import m_BS9CCNE3S5TUFNHIJ32OO7LQRL7KJJGL11ILFSGJ4P0UQNCM from "./BS9CCNE3S5TUFNHIJ32OO7LQRL7KJJGL11ILFSGJ4P0UQNCM.esm.js";
import m_EK978L6BL46HANBE7VVDPQFT5RPFM20Q1HGQFPT8LT6GBT2H from "./EK978L6BL46HANBE7VVDPQFT5RPFM20Q1HGQFPT8LT6GBT2H.esm.js";
import m_U6GBIV13KQMJJGSDETCK7M4LL6574J6IO457HT28GBPGQH79 from "./U6GBIV13KQMJJGSDETCK7M4LL6574J6IO457HT28GBPGQH79.esm.js";
import m_9KDJH0K8DPP26MEDLSG2R9NHQDA7PLQSGFR0LG675H7N0UF7 from "./9KDJH0K8DPP26MEDLSG2R9NHQDA7PLQSGFR0LG675H7N0UF7.esm.js";
import m_VP23OVGUHPL2NHB8NK5N9BK3TB6JS1IJDTCHS6B76O1M5OEK from "./VP23OVGUHPL2NHB8NK5N9BK3TB6JS1IJDTCHS6B76O1M5OEK.esm.js";
import m_O9RT4UQMHB2I4S528M1FNGEVS8OG98F3DTGLQIKCTUCQ5UJM from "./O9RT4UQMHB2I4S528M1FNGEVS8OG98F3DTGLQIKCTUCQ5UJM.esm.js";
import m_9TGT770GMNS7RRU1BAOCDMRT55OJD6GTB2D79G5E8V9LNRI1 from "./9TGT770GMNS7RRU1BAOCDMRT55OJD6GTB2D79G5E8V9LNRI1.esm.js";
import m_888RQCPAKFEI0U26LLCSB4K7MQUE6G1CTIN7G3M64641TT41 from "./888RQCPAKFEI0U26LLCSB4K7MQUE6G1CTIN7G3M64641TT41.esm.js";
import m_KB1DH2MM5JK33CL21MEMBIIM4IQPDCT1HH8FN7OAIASQMOTE from "./KB1DH2MM5JK33CL21MEMBIIM4IQPDCT1HH8FN7OAIASQMOTE.esm.js";
import m_IFBHE2J4I2ARGB90LS0FE89FL21E0QNI72ER82P21SSF557R from "./IFBHE2J4I2ARGB90LS0FE89FL21E0QNI72ER82P21SSF557R.esm.js";
const _module_map = {"./ruler": m_QQ2PJP7SE1FV7OJ2M4NP36EFRS5IJQT8G3OQPRT0507KHS04, "./rules_block/blockquote": m_TN12OD91GP0CUCC9GES6PCR3MJO0HP5UB5EOHEFK9KI2LJLM, "./rules_block/code": m_D1TE8ES05J0BT6F4PTNEQQINJH41THEGUK3K7DIBC9SPKAFJ, "./rules_block/fence": m_BS9CCNE3S5TUFNHIJ32OO7LQRL7KJJGL11ILFSGJ4P0UQNCM, "./rules_block/heading": m_EK978L6BL46HANBE7VVDPQFT5RPFM20Q1HGQFPT8LT6GBT2H, "./rules_block/hr": m_U6GBIV13KQMJJGSDETCK7M4LL6574J6IO457HT28GBPGQH79, "./rules_block/html_block": m_9KDJH0K8DPP26MEDLSG2R9NHQDA7PLQSGFR0LG675H7N0UF7, "./rules_block/lheading": m_VP23OVGUHPL2NHB8NK5N9BK3TB6JS1IJDTCHS6B76O1M5OEK, "./rules_block/list": m_O9RT4UQMHB2I4S528M1FNGEVS8OG98F3DTGLQIKCTUCQ5UJM, "./rules_block/paragraph": m_9TGT770GMNS7RRU1BAOCDMRT55OJD6GTB2D79G5E8V9LNRI1, "./rules_block/reference": m_888RQCPAKFEI0U26LLCSB4K7MQUE6G1CTIN7G3M64641TT41, "./rules_block/state_block": m_KB1DH2MM5JK33CL21MEMBIIM4IQPDCT1HH8FN7OAIASQMOTE, "./rules_block/table": m_IFBHE2J4I2ARGB90LS0FE89FL21E0QNI72ER82P21SSF557R};
const _require	  = function(module){ return _module_map[module]; };
const _module	  = {exports:{}};

(function(require, module, exports){
	let _module_map = undefined, _require = undefined, _module = undefined;
	return (function(require,module,exports){
/** internal
 * class ParserBlock
 *
 * Block-level tokenizer.
 **/
'use strict';


var Ruler           = require('./ruler');


var _rules = [
  // First 2 params - rule name & source. Secondary array - list of rules,
  // which can be terminated by this one.
  [ 'table',      require('./rules_block/table'),      [ 'paragraph', 'reference' ] ],
  [ 'code',       require('./rules_block/code') ],
  [ 'fence',      require('./rules_block/fence'),      [ 'paragraph', 'reference', 'blockquote', 'list' ] ],
  [ 'blockquote', require('./rules_block/blockquote'), [ 'paragraph', 'reference', 'blockquote', 'list' ] ],
  [ 'hr',         require('./rules_block/hr'),         [ 'paragraph', 'reference', 'blockquote', 'list' ] ],
  [ 'list',       require('./rules_block/list'),       [ 'paragraph', 'reference', 'blockquote' ] ],
  [ 'reference',  require('./rules_block/reference') ],
  [ 'heading',    require('./rules_block/heading'),    [ 'paragraph', 'reference', 'blockquote' ] ],
  [ 'lheading',   require('./rules_block/lheading') ],
  [ 'html_block', require('./rules_block/html_block'), [ 'paragraph', 'reference', 'blockquote' ] ],
  [ 'paragraph',  require('./rules_block/paragraph') ]
];


/**
 * new ParserBlock()
 **/
function ParserBlock() {
  /**
   * ParserBlock#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of block rules.
   **/
  this.ruler = new Ruler();

  for (var i = 0; i < _rules.length; i++) {
	this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });
  }
}


// Generate tokens for input range
//
ParserBlock.prototype.tokenize = function (state, startLine, endLine) {
  var ok, i,
	  rules = this.ruler.getRules(''),
	  len = rules.length,
	  line = startLine,
	  hasEmptyLines = false,
	  maxNesting = state.md.options.maxNesting;

  while (line < endLine) {
	state.line = line = state.skipEmptyLines(line);
	if (line >= endLine) { break; }

	// Termination condition for nested calls.
	// Nested calls currently used for blockquotes & lists
	if (state.sCount[line] < state.blkIndent) { break; }

	// If nesting level exceeded - skip tail to the end. That's not ordinary
	// situation and we should not care about content.
	if (state.level >= maxNesting) {
	  state.line = endLine;
	  break;
	}

	// Try all possible rules.
	// On success, rule should:
	//
	// - update `state.line`
	// - update `state.tokens`
	// - return true

	for (i = 0; i < len; i++) {
	  ok = rules[i](state, line, endLine, false);
	  if (ok) { break; }
	}

	// set state.tight if we had an empty line before current tag
	// i.e. latest empty line should not count
	state.tight = !hasEmptyLines;

	// paragraph might "eat" one newline after it in nested lists
	if (state.isEmpty(state.line - 1)) {
	  hasEmptyLines = true;
	}

	line = state.line;

	if (line < endLine && state.isEmpty(line)) {
	  hasEmptyLines = true;
	  line++;
	  state.line = line;
	}
  }
};


/**
 * ParserBlock.parse(str, md, env, outTokens)
 *
 * Process input string and push block tokens into `outTokens`
 **/
ParserBlock.prototype.parse = function (src, md, env, outTokens) {
  var state;

  if (!src) { return; }

  state = new this.State(src, md, env, outTokens);

  this.tokenize(state, state.line, state.lineMax);
};


ParserBlock.prototype.State = require('./rules_block/state_block');


module.exports = ParserBlock;

})(require, module, exports);
})(_require, _module, _module.exports);

export default _module.exports;
