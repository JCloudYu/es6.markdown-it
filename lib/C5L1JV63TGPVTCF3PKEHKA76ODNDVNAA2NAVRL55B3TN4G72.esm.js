/**
Copyright (c) 2014 Vitaly Puzrin, Alex Kocharin.

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
**/

import m_QQ2PJP7SE1FV7OJ2M4NP36EFRS5IJQT8G3OQPRT0507KHS04 from "./QQ2PJP7SE1FV7OJ2M4NP36EFRS5IJQT8G3OQPRT0507KHS04.esm.js";
import m_9AL963GK3IOILE4RRJ1GU7V7HLECJTP7HL4UQ6EUILJTO22A from "./9AL963GK3IOILE4RRJ1GU7V7HLECJTP7HL4UQ6EUILJTO22A.esm.js";
import m_70IOEEN8V5A2VNEIHQ1C8M87CAC2PK2CUOJAJFSCAK0DLL52 from "./70IOEEN8V5A2VNEIHQ1C8M87CAC2PK2CUOJAJFSCAK0DLL52.esm.js";
import m_02Q8IM4SJ8IRL4P3TF0M2A5SPE1TSBGK82F1I7AH6OBSSIK3 from "./02Q8IM4SJ8IRL4P3TF0M2A5SPE1TSBGK82F1I7AH6OBSSIK3.esm.js";
import m_KU9RRLVH7PU0ASBJJHOTSUTCIP0ML09QCM5E73F5TDKTS77A from "./KU9RRLVH7PU0ASBJJHOTSUTCIP0ML09QCM5E73F5TDKTS77A.esm.js";
import m_HM0CHPJGG1J1OGVJ5J5F1HS08MIOKS0A8O23Q28L6T7QIQLR from "./HM0CHPJGG1J1OGVJ5J5F1HS08MIOKS0A8O23Q28L6T7QIQLR.esm.js";
import m_DKNMB7GPBB5TK3KCBRAG7KJHGRTCT659S2331C1GVI6GDU0R from "./DKNMB7GPBB5TK3KCBRAG7KJHGRTCT659S2331C1GVI6GDU0R.esm.js";
import m_SOP940B8KT4K848U5ACAAS87M2D6TOUVRAANFMU2V2MF043V from "./SOP940B8KT4K848U5ACAAS87M2D6TOUVRAANFMU2V2MF043V.esm.js";
import m_I34AIJ64AP5M88TTNSPQAF45TD14BCBC551D8SFPVB2UV8Q5 from "./I34AIJ64AP5M88TTNSPQAF45TD14BCBC551D8SFPVB2UV8Q5.esm.js";
import m_FGOQLQ9CTMNI5503IDBGR79SNQB7FN02R9ODTUVTATJT0M6G from "./FGOQLQ9CTMNI5503IDBGR79SNQB7FN02R9ODTUVTATJT0M6G.esm.js";
import m_27BHTPS8ELID4TT923HVAU79HME2TG6MO2V1F44ELJNTF5QD from "./27BHTPS8ELID4TT923HVAU79HME2TG6MO2V1F44ELJNTF5QD.esm.js";
import m_LIFL4H962M462QIFFB6HCAKGE30RGC4VO3G36K9TSO47O5TL from "./LIFL4H962M462QIFFB6HCAKGE30RGC4VO3G36K9TSO47O5TL.esm.js";
import m_TVSBEFITOH2DN925RFDOH07817THI2JR2AVQMCQR8F2MMEG7 from "./TVSBEFITOH2DN925RFDOH07817THI2JR2AVQMCQR8F2MMEG7.esm.js";
import m_3N4412UFK6C994EL585D40PNQKT2PR86M8I2A7EKJB74F1R5 from "./3N4412UFK6C994EL585D40PNQKT2PR86M8I2A7EKJB74F1R5.esm.js";
import m_FFCB8JV0VHQOJU61B0NO1NGO2E3TPM2OD3UFSIKALL3IPIKS from "./FFCB8JV0VHQOJU61B0NO1NGO2E3TPM2OD3UFSIKALL3IPIKS.esm.js";
const _module_map = {"./ruler": m_QQ2PJP7SE1FV7OJ2M4NP36EFRS5IJQT8G3OQPRT0507KHS04, "./rules_inline/autolink": m_9AL963GK3IOILE4RRJ1GU7V7HLECJTP7HL4UQ6EUILJTO22A, "./rules_inline/backticks": m_70IOEEN8V5A2VNEIHQ1C8M87CAC2PK2CUOJAJFSCAK0DLL52, "./rules_inline/balance_pairs": m_02Q8IM4SJ8IRL4P3TF0M2A5SPE1TSBGK82F1I7AH6OBSSIK3, "./rules_inline/emphasis": m_KU9RRLVH7PU0ASBJJHOTSUTCIP0ML09QCM5E73F5TDKTS77A, "./rules_inline/entity": m_HM0CHPJGG1J1OGVJ5J5F1HS08MIOKS0A8O23Q28L6T7QIQLR, "./rules_inline/escape": m_DKNMB7GPBB5TK3KCBRAG7KJHGRTCT659S2331C1GVI6GDU0R, "./rules_inline/html_inline": m_SOP940B8KT4K848U5ACAAS87M2D6TOUVRAANFMU2V2MF043V, "./rules_inline/image": m_I34AIJ64AP5M88TTNSPQAF45TD14BCBC551D8SFPVB2UV8Q5, "./rules_inline/link": m_FGOQLQ9CTMNI5503IDBGR79SNQB7FN02R9ODTUVTATJT0M6G, "./rules_inline/newline": m_27BHTPS8ELID4TT923HVAU79HME2TG6MO2V1F44ELJNTF5QD, "./rules_inline/state_inline": m_LIFL4H962M462QIFFB6HCAKGE30RGC4VO3G36K9TSO47O5TL, "./rules_inline/strikethrough": m_TVSBEFITOH2DN925RFDOH07817THI2JR2AVQMCQR8F2MMEG7, "./rules_inline/text": m_3N4412UFK6C994EL585D40PNQKT2PR86M8I2A7EKJB74F1R5, "./rules_inline/text_collapse": m_FFCB8JV0VHQOJU61B0NO1NGO2E3TPM2OD3UFSIKALL3IPIKS};
const _require	  = function(module){ return _module_map[module]; };
const _module	  = {exports:{}};

(function(require, module, exports){
	let _module_map = undefined, _require = undefined, _module = undefined;
	return (function(require,module,exports){
/** internal
 * class ParserInline
 *
 * Tokenizes paragraph content.
 **/
'use strict';


var Ruler           = require('./ruler');


////////////////////////////////////////////////////////////////////////////////
// Parser rules

var _rules = [
  [ 'text',            require('./rules_inline/text') ],
  [ 'newline',         require('./rules_inline/newline') ],
  [ 'escape',          require('./rules_inline/escape') ],
  [ 'backticks',       require('./rules_inline/backticks') ],
  [ 'strikethrough',   require('./rules_inline/strikethrough').tokenize ],
  [ 'emphasis',        require('./rules_inline/emphasis').tokenize ],
  [ 'link',            require('./rules_inline/link') ],
  [ 'image',           require('./rules_inline/image') ],
  [ 'autolink',        require('./rules_inline/autolink') ],
  [ 'html_inline',     require('./rules_inline/html_inline') ],
  [ 'entity',          require('./rules_inline/entity') ]
];

var _rules2 = [
  [ 'balance_pairs',   require('./rules_inline/balance_pairs') ],
  [ 'strikethrough',   require('./rules_inline/strikethrough').postProcess ],
  [ 'emphasis',        require('./rules_inline/emphasis').postProcess ],
  [ 'text_collapse',   require('./rules_inline/text_collapse') ]
];


/**
 * new ParserInline()
 **/
function ParserInline() {
  var i;

  /**
   * ParserInline#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of inline rules.
   **/
  this.ruler = new Ruler();

  for (i = 0; i < _rules.length; i++) {
	this.ruler.push(_rules[i][0], _rules[i][1]);
  }

  /**
   * ParserInline#ruler2 -> Ruler
   *
   * [[Ruler]] instance. Second ruler used for post-processing
   * (e.g. in emphasis-like rules).
   **/
  this.ruler2 = new Ruler();

  for (i = 0; i < _rules2.length; i++) {
	this.ruler2.push(_rules2[i][0], _rules2[i][1]);
  }
}


// Skip single token by running all rules in validation mode;
// returns `true` if any rule reported success
//
ParserInline.prototype.skipToken = function (state) {
  var ok, i, pos = state.pos,
	  rules = this.ruler.getRules(''),
	  len = rules.length,
	  maxNesting = state.md.options.maxNesting,
	  cache = state.cache;


  if (typeof cache[pos] !== 'undefined') {
	state.pos = cache[pos];
	return;
  }

  if (state.level < maxNesting) {
	for (i = 0; i < len; i++) {
	  // Increment state.level and decrement it later to limit recursion.
	  // It's harmless to do here, because no tokens are created. But ideally,
	  // we'd need a separate private state variable for this purpose.
	  //
	  state.level++;
	  ok = rules[i](state, true);
	  state.level--;

	  if (ok) { break; }
	}
  } else {
	// Too much nesting, just skip until the end of the paragraph.
	//
	// NOTE: this will cause links to behave incorrectly in the following case,
	//       when an amount of `[` is exactly equal to `maxNesting + 1`:
	//
	//       [[[[[[[[[[[[[[[[[[[[[foo]()
	//
	// TODO: remove this workaround when CM standard will allow nested links
	//       (we can replace it by preventing links from being parsed in
	//       validation mode)
	//
	state.pos = state.posMax;
  }

  if (!ok) { state.pos++; }
  cache[pos] = state.pos;
};


// Generate tokens for input range
//
ParserInline.prototype.tokenize = function (state) {
  var ok, i,
	  rules = this.ruler.getRules(''),
	  len = rules.length,
	  end = state.posMax,
	  maxNesting = state.md.options.maxNesting;

  while (state.pos < end) {
	// Try all possible rules.
	// On success, rule should:
	//
	// - update `state.pos`
	// - update `state.tokens`
	// - return true

	if (state.level < maxNesting) {
	  for (i = 0; i < len; i++) {
		ok = rules[i](state, false);
		if (ok) { break; }
	  }
	}

	if (ok) {
	  if (state.pos >= end) { break; }
	  continue;
	}

	state.pending += state.src[state.pos++];
  }

  if (state.pending) {
	state.pushPending();
  }
};


/**
 * ParserInline.parse(str, md, env, outTokens)
 *
 * Process input string and push inline tokens into `outTokens`
 **/
ParserInline.prototype.parse = function (str, md, env, outTokens) {
  var i, rules, len;
  var state = new this.State(str, md, env, outTokens);

  this.tokenize(state);

  rules = this.ruler2.getRules('');
  len = rules.length;

  for (i = 0; i < len; i++) {
	rules[i](state);
  }
};


ParserInline.prototype.State = require('./rules_inline/state_inline');


module.exports = ParserInline;

})(require, module, exports);
})(_require, _module, _module.exports);

export default _module.exports;
